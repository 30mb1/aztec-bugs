{
  "name": "Test",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/9XdVXBUZxyG8U1aoO4N7u6r2bNocHd3smSDu5MKpe7UvaXUnbq3lLpT95ZC3QW55bzDMmS45eXi2ZkzJDeZ5wdkd8+e7/y/XZFIZFtkz6MgPArDo0r+673fV93v+2r5rys/9n5fkv8zES1OJnPpeC6WiJVG45lskIomU9niIBbEUkGqLB4kErkgGaQz2Uw6moklE7lYeSqTKI/ueVSv9LOiB/g4mJ01IJ01IZ21IJ21IZ11IJ11IZ31IJ31IZ0NIJ0NIZ2NIJ2NIZ1NIJ1NIZ3NIJ3NIZ0tIJ0tIZ2tIJ2tIZ1tIJ1tIZ3tIJ3tIZ1RSGcM0hmHdCYgnUlIZwrSWQzpTEM6A0hnBtLZAdLZEdLZCdLZGdLZBdLZFdJZAunsBunsDunsAensCensBensDensA+nsC+nsB+nsD+kcAOkcCOkcBOkcDOkcAukcCukcBukcDukcAekcCekcBekcDekcA+kcC+kcB+kcD+mcAOmcCOmcBOmcDOmcAumcCukshXRmIZ3TIJ1lkM4cpLMc0jkd0jkD0jkT0jkL0jkb0jkH0jkX0jkP0jkf0rkA0rkQ0rkI0rkY0rkE0rkU0rkM0rkc0rkC0rkS0rkK0llxkDoL9+uMHtgjVmA0nwIxFxrNp0LMhxjNp0HMhxrNp0PMVYzm1RBzVaP5DIi5mtG8BmKubjSfCTHXMJrPgphrGs1nQ8y1jOZzIObaRvO5EHMdo/k8iLmu0Xw+xFzPaL4AYq5vNF8IMTcwmi+CmBsazRdDzI2M5ksg5sZG86UQcxOjeS3E3NRovgxibmY0Xw4xNzear4CYWxjNV0LMLY3mqyDmVkbz1RBza6P5Goi5jdF8LcTc1mi+DmJuZzRfDzG3N5pvgJijRvONEHPMaL4JYo4bzTdDzAmj+RaIOWk0r4OYU0bzrRBzsdG8HmJOG823QcyB0Xw7xJwxmu+AmDsYzXdCzB2N5rsg5k5G890Qc2ej+R6IuYvRfC/E3NVovg9iLjGa74eYuxnND0DM3Y3mByHmHkbzQxBzT6N5A8Tcy2h+GGLubTQ/AjH3MZofhZj7Gs2PQcz9jObHIeb+RvMTEPMAo/lJiHmg0fwUxDzIaH4aYh5sND8DMQ8xmp+FmIcazc9BzMOM5uch5uFG8wsQ8wij+UWIeaTRvBFiHmU0vwQxjzaaN0HMY4zmlyHmsUbzKxDzOKP5VYh5vNH8GsQ8wWh+HWKeaDS/ATFPMprfhJgnG81vQcxTjOa3IeapRvM7EHOp0fwuxJw1mt+DmKcZze9DzGVG82aIOWc0fwAxlxvNH0LM043mjyDmGUbzxxDzTKP5E4h5ltH8KcQ822j+DGKeYzR/DjHPNZq/gJjnGc1fQszzjeavIOYFRvPXEPNCo/kbiHmR0fwtxLzYaP4OYl5iNG+BmJcazd9DzMuM5q0Q83KjeRvEvMJo/gFiXmk0/wgxrzKaf4KYK4zmnyHmw4zmXyDmw43mXyHmI4zm3yDmI43m3yHmo4zmPyDmo43mPyHmY4zmvyDmY43mvyHm44zmfyDm443mfyHmE4zm/yDmE43m/yHmk4zm7RDzyUbzDoi5yGjeaTQX5X9OQd6sfTC1L6T2SdS+gdpHT+eEOkfSOYPeQ+s9pd5j6T2HXoP1mqTnaD1n6XdY/6f1b1xU6e+zIv+n9kDVnqDaI1N7Rq4OD+0puCY8tOec9mDTnmTao0t7VmkPJ+1ppD1+tOeN9oDRnijaI0R7ZqwND+2poD0GNHNfM+g1k10zyjWzWzOsNdNZM44181czcDUTVjNSNTN0XXhopuT68NDMQc3g00w6zWjTzDLN8NJMK8140swjzQDSTBzNiNHMlA3hoZkamjGhmQuaQaB78nWPuu7Z1j3MuqdX97jqnk/dA6l7AnWPnO4Z2xgeuqdoU3jonhPdg6F7ErRGX2vWtYZba5q1xldrXrUGVGsitUZQa+Y2h4fWVGmNkdbcaA2K1mRojYKu2esatq7p6hqnrvnpGpiuCekaia4ZbAkPfaa8NTz0maM+g9NnUvqMRp9Z6Bxe57Q6x9M5j84B9J5Y7xH1nknvIfSaqtcYPefqOUi/kzsj+x67AeA6V5skugAA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "test",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "test_get",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "test_note::TestNote",
          "fields": [
            {
              "name": "value",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            },
            {
              "name": "owner",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "header",
              "type": {
                "kind": "struct",
                "path": "aztec::note::note_header::NoteHeader",
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_slot",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_transient",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            }
          ]
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d2O5bh1huF76eNBoPVLam4lyIGROIABwwlinxlz75GR2bvbkVzqMdmlVyKP4sC7ey8uuj4tquuR/vrlj//177/7yx/+609//vLzX78s/7J++flf//rlz//9uz/97f//819+9z9/+fLz8tOX3//pP7b/+8tPX/7zD3/8/Zef5Zefdp9Syyy/fnL7z1Xen7b18ONl8ffHi9RvP/5vP221yEIqRkjFKKkYIxXjpGKCVEySiimkYiqpGFICKymBlZTASkpgJSWwkhJYSQmspARWUgIrKYGVlMBGSmAjJbCREthICWykBDZSAhspgY2UwEZKYCMlsJMS2EkJ7KQEdlICOymBnZTATkpgJyWwkxLYSQkcpAQOUgIHKYGDlMBBSuAgJXCQEjhICRykBA5SAicpgZOUwElK4CQlcJISOEkJnKQETlICJymBk5TAhZTAhZTAhZTAhZTAhZTAhZTAhZTAhZTAhZTAhZTAlZTAlZTAlZTAlZTAlZTAlZTAlZTAlZTAlZTAlZTAKymBV1ICr6QEXkkJvJISeCUl8EpK4JWUwCspgVdSAstCimBZSBksCymEZSGlsCykGJaFlMOykIJYFlISy0KKYllQWQzjcagsZgE5lpBjETmWkWMhOZaSYzE5lJMTFJQTlJQTFJUTlJUTFJYTlJYTFJcTlJcTFJgTlJgTFJkTlJkTFJoTlJoTFJsTlJsTFJwTlJwTFJ0TlJ0TFJ4TlJ4TFJ8TlJ8TFKATlKATFKETlKETFKITlKITFKMTlKMTFKQTlKQTFKUTlKUTFKYTlKYTFKcTlKcTFKgTlKgTFKkTlKkTFKoTlKoTFKsTlKsTFKwTlKwTFK0TlK0TFK4TlK4TFK8TlK8TFLATlLATFLETlLETFLITlLITFLMTlLMTFLQTlLQTFLUTlLUTFLYTlLYTFLcTlLcTFLgTlLgTFLkTlLkTFLoTlLoTFLsTlLtTlLtTlLtTlLtTlLvThZTFinJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3inJ3hnJ3hnJ3hnJ3hnJ3tpCy2FDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlDuzlHuzlHuzlHuzlHuzhdSFjvK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3TnK3QXK3QXK3QXK3QXK3cVCyuJAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtAubtEubtEubtEubtEubtcSFmcKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHeXKHdXUO6uoNxdQbm7gnJ323+PqoaUxQXl7grK3RWUuysod1dQ7q6g3F1BubuCcncF5e4Kyt0VlLsrKHdXUO6uoNxdQbm7gnJ3BeXuCsrdFZS7Kyh3V1DurqDcXUG5u4JydwXl7grK3RWUuysod1dQ7q6g3F1BubuCcncF5e4Kyt0VlLsrKHdXUO6uoNxdQbm7gnJ3BeXuCsrdFZS7Kyh3V1DurqDcXUG5u4JydwXl7grK3RWUuysod1dQ7q6g3F1BubuCcncF5e4Kyt0VlLsrKHdXUO6uoNxdQbm7gnJ3BeXuCsrdFZS7Kyh3V1DurqDcXUG5u4JydwXl7grK3RWUuysod1dQ7q6g3F1BubuCcncF5e4Kyt0VlLsrKHdXUO6uoNxdQbm7gnJ3BeXuCsrdFZS7Kyh3V1DurqDcXUW5u4pydxXl7irK3dWFlMUV5e4qyt1VlLurKHdXUe6uotxdRbm7inJ3FeXuKsrdVZS7qyh3V1HurqLcXUW5u4pydxXl7irK3VWUu6sod1dR7q6i3F1FubuKcncV5e4qyt1VlLurKHdXUe6uotxdRbm7inJ3FeXuKsrdVZS7qyh3V1HurqLcXUW5u4pydxXl7irK3VWUu6sod1dR7q6i3F1FubuKcncV5e4qyt1VlLurKHdXUe6uotxdRbm7inJ3FeXuKsrdVZS7qyh3V1HurqLcXUW5u4pydxXl7irK3VWUu6sod1dR7q6i3F1FubuKcncV5e4qyt1VlLurKHdXUe6uotxdRbm7inJ3FeXuKsrdVZS7qyh3V1HurqLcXUW5u4pydxXl7irK3VWUu6sod1dR7q6i3F1FubsV5e5WlLtbUe5uRbm7dSFl8YpydyvK3a0od7ei3N2Kcncryt2tKHe3otzdinJ3K8rdrSh3t6Lc3YpydyvK3a0od7ei3N2Kcncryt2tKHe3otzdinJ3K8rdrSh3t6Lc3YpydyvK3a0od7ei3N2Kcncryt2tbe7ug7/+n6umKYu7V9OUxd2racri7tU0ZXHvatrcXfdqmrK4ezVNWdy9mqYs7l5NUxZ3rwaVxW3urns1qCxuc3fdq0FlcZu7614NKovb3F33alBZ3ObuuleDyuI2d9e9GlQWt7m77tWgsrjN3XWvBpXFbe6uezWoLG5zd92rQWVxm7vrXg0qi9vcXfdqUFnc5u66V4PK4jZ3170aVBa3ubvu1aCyuM3dda8GlcVt7q57NagsbnN33atBZXGbu+teDSqL29xd92pQWdzm7rpXg8riNnfXvRpUFre5u+7VoLK4zd11rwaVxW3urns1qCxuc3fdq0FlcZu7614NKYtlaYN3/cshpfFWDimOt3JIebyVQwrkrRxSIm/lkCJ5K4eUyVs5pFDeymGlchvB618OK5XbEF7/clip3Mbw+pfDSuU2iNe/HFYqt1G8/uWwUrkN4/Uvh5XKbRyvfzmsVG4Def3LYaVyG8nrXw4rldtQXv9yWKncxvL6l8NK5TaY178cViq30bz+5bBSGYXztnJYqYzieVs5rFRGAb2tHFYqo4jeVg4rlVFIbyuHlcoopreVw0plFNTbymGlMorqbeWwUhmF9bZyWKmM4npbOaxURoG9rRxWKqPI3lYOK5VRaG8rh5XKKLa3lcNKZRTc28phpTKK7m3lsFIZhfe2clipjOJ7WzmsVEYBvq0cViqjCN9WDiuVUYhvK4eVyijGt5XDSmUU5NvKYaUyivJt5bBSGYX5tnJYqYzifFs5rFRGgb6tHFYqo0jfVg4rlVGobyuHlcoo1reVw0plFOzbymGlMor2beWgUllYtk9Ytk9Ytk9Ytk8WVCoLy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/YJy/Ypy/Ypy/Ypy/Ypy/bpgkplZdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Zdk+Y9k+Y9k+Y9k+Y9k+W1CpbCzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzbZyzb5yzb5yzb5yzb5yzb5wsqlZ1l+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+5xl+4Jl+4Jl+4Jl+4Jl+2JBpXKwbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+wbF+ybF+ybF+ybF+ybF8uqFROlu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu0rLNtXWLavsGxfYdm+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",
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJzlV8tu2zAQ/BedjYD74sO/UvRgNCkQIHCK2jdD/x4qEUnF3lBgpRaCe7OA2eXskLs7vnQvrz8O5+fX46nbXzrq9t8u3enX4Th8nc6H3+duDyJh1z0dH+NPi6bfdT+fX57iR7+7wSILjVgUgIx1VgFb60esM74OFbEjVJzLUKtRIHQjlCQUqOm/7zq+g/rYc4KSn9Z3CwWXCKCnDCU3SCF3IIVwyFB/ddV2s/WFVJ+lT/VF0m6rpL1Ljy4Q1i8lnpv6zxQC4If6/FbrCyypPh+uLiVslTQYk/KC4eu3BOaf8naQeHtrptCBCmyHCi6mIiEtGLSWZqgEk6iQzVDWoOwTVEzJKqRdvBdMdL0reQNqYDAZDMx1MEIaTsilD+RdueXm4H9Vbrnt+EvKCWTlJp2iKochaRENVskaGqVYbjvuRorlDqVFikBpgIZAUykGKst9x59S8ddUdIvgbN50zkuVSs3/g77LG7Kv5L5RX84NRGreF/V9a8nk2Ucz9xmyifMFye/Ggh7Ul4uYCOGN7vSgvrB6iPoS6iHq9dZCrH4K58HPXMzGh6+y+in1EN2MzcSotzgTo9obYpdjZtw7E2doebTgxvSqB1gvvboo10uvLp+W9PmvDU92RE6vtsV66dUWWik9fNUI2S4JTHrnY4H59kEQY5onQYxpHgUxpnkWIHzRpmJSkKUylG0Uru/fAL/Tn1s=",
      "eJztnd2O5MyNpu/lOzYWGf+Sb2WxB8buLDDAwLNY+2zge5800MqqdlMV6ogoxpMKHtmwxRbjjRCTZOmh/uuP//jP//2Xv//7f/71b3/8+b/+ePwP9/jjz//zv/742//7y1//+T/87e9/+f9//+PPjz/98W9//T/P//zHn/74v//+H//2x5/dP/70y1U+5Fx+XPn875t7XR128fLyiK/Li9s+X/6//vRPZxzJGU9yJpCciSRnEsmZTHKmkJzZSM7sIGc8KQJ7UgT2pAjsSRHYkyKwJ0VgT4rAnhSBPSkCe1IEDqQIHEgROJAicCBF4ECKwIEUgQMpAgdSBA6kCBxIETiSInAkReBIisCRFIEjKQJHUgSOpAgcSRE4kiJwJEXgRIrAiRSBEykCJ1IETqQInEgROJEicCJF4ESKwIkUgTMpAmdSBM6kCJxJETiTInAmReBMisCZFIEzKQJnUgQupAhcSBG4kCJwIUXgQorAhRSBCykCF1IELqQIXEgReCNF4I0UgTdSBN5IEXgjReCNFIE3UgTeSBF4I0XgjRSBd1IE3kkReCdF4J0UgXdSBN5JEXgnReCdFIF3UgTeSRHYPUgh2D1IMdg9SEHYPUhR2D1IYdg9SHHYPUiB2D1Ikdg9SKHYPVCxGIbHoWIxC5BjEXIsRI7FyLEgORYlx8LkUJycQ4FyDkXKORQq51CsnEPBcg5FyzkULudQvJxDAXMORcw5FDLnUMycQ0FzDkXNORQ251DcnEOBcw5FzjkUOudQ7JxDwXMORc85FD7nUPycQwF0DkXQORRC51AMnUNBdA5F0TkURudQHJ1DgXQORdI5FErnUCydQ8F0DkXTORRO51A8nUMBdQ5F1DkUUudQTJ1DQXUORdU5FFbnUFydQ4F1DkXWORRa51BsnUPBdQ5F1zkUXudQfJ1DAXYORdg5FGLnUIydQ0F2DkXZORRm51CcnUOBdg5F2jkUaudQrJ1DwXYORds5FG7nULydQwF3DkXcORRy51DMnUNBdw5F3TkUdudQ3J1HcXcexd15FHfnUdydf5BisUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR351HcnUdxdx7F3XkUd+dR3J1HcXcexd15FHfnUdydR3F3HsXdeRR3F1DcXUBxdwHF3QUUdxcepFgcUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd0FFHcXUNxdQHF3AcXdBRR3F1DcXUBxdwHF3QUUdxdQ3F1AcXcBxd1FFHcXUdxdRHF3EcXdxQcpFkcUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdxHF3UUUdxdR3F1EcXcRxd1FFHcXUdxdRHF3EcXdRRR3F1HcXURxdwnF3SUUd5dQ3F1CcXfpQYrFCcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdQnF3CcXdJRR3l1DcXUJxdwnF3SUUd5dQ3F1CcXcJxd0lFHeXUNxdRnF3GcXdZRR3l1HcXX6QYnFGcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd5dR3F1GcXcZxd1lFHeXUdxdRnF3GcXdZRR3l1HcXUZxdxnF3WUUd1dQ3F1BcXcFxd0VFHf3/P9R3pBicUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF3RUUd1dQ3F1BcXcFxd0VFHdXUNxdQXF3BcXdFRR3V1DcXUFxdwXF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YLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2BxfYFFtsXWGxfYLF9gcX2BRbbF1hsX2CxfYHF9gUW2xdYbF9gsX2RxfZFFtsXWWxfZLF98YGKypHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2SxfZHF9kUW2xdZbF9ksX2RxfZFFtsXWWxfZLF9kcX2RRbbF1lsX2KxfYnF9iUW25dYbF96oKJyYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW25dYbF9isX2JxfYlFtuXWGxfYrF9icX2JRbbl1hsX2KxfYnF9iUW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YV1TOx5fHA/rmtrx+OJ4WNfUjscXx8O6pvc+HuXzxcemWy90wU23DueCm259y1mbntxr03PlUr8fQjyf0g/RpHmPtZ9za0Qutd8DRlbafr/TflurcK39tt7fWvttzby19tu6c2vtt7Xb1tpv67Sttd/WZFtrv62/ttZ+W39tqf0e8KkI2+932m/rr62139ZfW2u/rb+21n5bf22t/bb+2nvtd3h83u9jF61rdoddtF7Y2F0shxd72L6+NJbjn00xS1tjbSvs1liHibo1A74naFvzTVtjfRvs1liLBbs11g3Bbo01LrBbYz0G7NZY4wC7NdYNwG6NdQOwW2PdAOrWDPjquG3NN22NdQOwW2PdAOzWWDcAuzXWDcBujXUDCFuzS1tj3QDs1lg3oLo1PsePfzl9fXEuhxglJklvK/F19ba6XVXvYsW4rt5WYevqbWWzrt5WC+vqbQWurt5WterqbaWort5WX+rqbfWlrt5WX6rqvVl9qau31Ze6elt9qau31Ze6elt9qau31Zffpvcm6W31pa7eS+bfbs/p0Pvhw9cSIr6P4V+LczF8fXHJxz9cNvf50h9bvi9ZArzflo/7Nta+ZBGy9I4vWQYtveNLFmJL7/iSpeDSO75kMbr0ji9ZDi+940v+wXfpHV/yT85L77g13dba8fiwnttqO249t9V23Hpuq+249dxW23Hrua2249ZzW23Hree22o5bz221Hbee29vtePl88bGP1km7xT4664/dYx+t6zVwH2d8eSw6a2O9/RZaX+rtt9AaTW+/hdY5evsttFbQ22+h9XbefgutWfP2W2h9mnffQm8tmrffQuvOvP0WWnfm7bfQujNvv4XWnXn7LbTuzNtvoXVn3n4LrTvz9lto3ZnpWxgen7fw2BjruTA3Jlgnpboxw75rFoM1PTTVtv6EptrWStBU26p+TbWtQNdU22ppTbWt7NVU2ypUTbWt7FRUO1otqam21ZKaalstqam21ZKaalstqam21ZKaalstqam21ZKaalst+U1q75LaVksqqp3WzElKOdR2W/AVCd/gAz8xrZntMPZx3IyatGYadbttXDM/u902rpn43W4b18wo77aNec0/e9xuG9f8e8rttnHNP9TcbhvX/AvQ7bbR2ji32Ebr4txiG62Lc4tttC7OLbbRuji32Ebr4txhG4t1cW6xjdbFucU2Whfn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"
    ],
    "fileMap": {
      "5": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\npub fn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\npub fn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\npub fn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "17": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\nfn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\nfn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar"
      },
      "18": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\nfn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul"
      },
      "33": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "37": {
        "source": "use dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0]\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/address"
      },
      "39": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 49),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 65),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 81),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 97),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 101),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 105),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 107),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 109),\n                encrypted_log_preimages_length: fields[111],\n                unencrypted_log_preimages_length: fields[112],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[113],\n                    nullifier_tree_root : fields[114],\n                    contract_tree_root : fields[115],\n                    l1_to_l2_messages_tree_root : fields[116],\n                    blocks_tree_root : fields[117],\n                    public_data_tree_root: fields[118],\n                    global_variables_hash: fields[119],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[120], fields[121]),\n                    constructor_vk_hash : fields[122],\n                    function_tree_root : fields[123],\n                    contract_address_salt : fields[124],\n                    portal_contract_address : fields[125],\n                },\n                chain_id: fields[126],\n                version: fields[127],\n            },\n            is_execution_request: fields[128] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/context"
      },
      "41": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(\n    context: &mut PublicContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/log"
      },
      "46": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/note/lifecycle"
      },
      "47": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/note/note_getter"
      },
      "49": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/note/note_hash"
      },
      "53": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/note/utils"
      },
      "60": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/oracle/get_public_key"
      },
      "61": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(\n    _owner: Point,\n) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/oracle/get_secret_key"
      },
      "65": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(preimage);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/oracle/notes"
      },
      "67": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T)  -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/oracle/logs"
      },
      "76": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse dep::std::hash::pedersen_with_separator;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_with_separator(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )[0]\n    } else {\n        pedersen_with_separator(\n            [storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )[0]\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note, owner: Option<Field>) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface);\n\n        note\n    }\n    // docs:end:get_note\n\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}\n",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/state_vars/singleton"
      },
      "80": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/types/vec"
      },
      "86": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/home/maga/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.14/yarn-project/aztec-nr/aztec/src/utils"
      },
      "92": {
        "source": "use dep::aztec::context::{PrivateContext, PublicContext, Context};\nuse dep::aztec::types::address::AztecAddress;\nuse dep::std::option::Option;\nuse dep::aztec::note::{\n    utils::compute_note_hash_for_read_or_nullify,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\n\n\n\nstruct TestNote {\n    value: u32,\n    owner: Field,\n    header: NoteHeader\n}\n\n\nglobal TEST_NOTE_SERIALIZED_LEN: Field = 2;\n\n\nimpl TestNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        Self {\n            value: value as u32,\n            owner: owner,\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn serialize(self: Self) -> [Field; TEST_NOTE_SERIALIZED_LEN] {\n        [\n            self.value as Field,\n            self.owner\n        ]\n    }\n\n    pub fn deserialize(preimage: [Field; TEST_NOTE_SERIALIZED_LEN]) -> Self {\n        TestNote {\n            value: preimage[0] as u32,\n            owner: preimage[1],\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        dep::std::hash::pedersen(self.serialize())[0]\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(TestNoteSerializationMethods, self);\n        let secret = get_secret_key(self.owner);\n        dep::std::hash::pedersen([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ])[0]\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialize(preimage: [Field; TEST_NOTE_SERIALIZED_LEN]) -> TestNote {\n    TestNote::deserialize(preimage)\n}\n\nfn serialize(note: TestNote) -> [Field; TEST_NOTE_SERIALIZED_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: TestNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: TestNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: TestNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut TestNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nglobal TestNoteSerializationMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/home/maga/projects/aztec-bugs/src/contracts/src/test_note"
      }
    }
  }
}